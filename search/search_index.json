{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"pipx \u2014 Install and Run Python Applications in Isolated Environments Documentation : https://pipxproject.github.io/pipx/ Source Code : https://github.com/pipxproject/pipx For comparison to other tools including pipsi, see Comparison to Other Tools . Install pipx On macOS: brew install pipx pipx ensurepath Upgrade pipx with brew update && brew upgrade pipx . Otherwise, install via pip: python3 -m pip install --user pipx python3 -m pipx ensurepath Upgrade pipx with python3 -m pip install --user -U pipx . Shell completions are available by following the instructions printed with this command: pipx completions For more details, see the installation instructions . Overview: What is pipx ? pipx is a tool to help you install and run end-user applications written in Python. It's roughly similar to macOS's brew , JavaScript's npx , and Linux's apt . It's closely related to pip. In fact, it uses pip, but is focused on installing and managing Python packages that can be run from the command line directly as applications. How is it Different from pip? pip is a general-purpose package installer for both libraries and apps with no environment isolation. pipx is made specifically for application installation, as it adds isolation yet still makes the apps available in your shell: pipx creates an isolated environment for each application and its associated packages. pipx does not ship with pip, but installing it is often an important part of bootstrapping your system. Where Does pipx Install Apps From? By default, pipx uses the same package index as pip, PyPI . pipx can also install from all other sources pip can, such as a local directory, wheel, git url, etc. Python and PyPI allow developers to distribute code with \"console script entry points\". These entry points let users call into Python code from the command line, effectively acting like standalone applications. pipx is a tool to install and run any of these thousands of application-containing packages in a safe, convenient, and reliable way. In a way, it turns Python Package Index (PyPI) into a big app store for Python applications. Not all Python packages have entry points, but many do. If you would like to make your package compatible with pipx, all you need to do is add a console scripts entry point. If you're a poetry user, use these instructions . Features pipx enables you to Expose CLI entrypoints of packages (\"apps\") installed to isolated environments with the install command. This guarantees no dependency conflicts and clean uninstalls! Easily list, upgrade, and uninstall packages that were installed with pipx Run the latest version of a Python application in a temporary environment with the run command Best of all, pipx runs with regular user permissions, never calling sudo pip install (you aren't doing that, are you? \ud83d\ude04). Walkthrough: Installing a Package and its Applications With pipx You can globally install an application by running pipx install PACKAGE This automatically creates a virtual environment, installs the package, and adds the package's associated applications (entry points) to a location on your PATH . For example, pipx install pycowsay makes the pycowsay command available globally, but sandboxes the pycowsay package in its own virtual environment. pipx never needs to run as sudo to do this. Example: >> pipx install pycowsay installed package pycowsay 2.0.3, Python 3.7.3 These apps are now globally available - pycowsay done! \u2728 \ud83c\udf1f \u2728 >> pipx list venvs are in /home/user/.local/pipx/venvs apps are exposed on your $PATH at /home/user/.local/bin package pycowsay 2.0.3, Python 3.7.3 - pycowsay # Now you can run pycowsay from anywhere >> pycowsay mooo ____ < mooo > ==== \\ \\ ^__^ (oo)\\_______ (__)\\ )\\/\\ ||----w | || || Installing from Source Control You can also install from a git repository. Here, black is used as an example. pipx install git+https://github.com/psf/black.git pipx install git+https://github.com/psf/black.git@branch # branch of your choice pipx install git+https://github.com/psf/black.git@ce14fa8b497bae2b50ec48b3bd7022573a59cdb1 # git hash pipx install https://github.com/psf/black/archive/18.9b0.zip # install a release Walkthrough: Running an Application in a Temporary, Sandboxed Environment This is an alternative to pipx install . pipx run downloads and runs the above mentioned Python \"apps\" in a one-time, temporary environment, leaving your system untouched afterwards. This can be handy when you need to run the latest version of an app, but don't necessarily want it installed on your computer. You may want to do this when you are initializing a new project and want to set up the right directory structure, when you want to view the help text of an application, or if you simply want to run an app in a one-off case and leave your system untouched afterwards. For example, the blog post How to set up a perfect Python project uses pipx run to kickstart a new project with cookiecutter , a tool that creates projects from project templates. A nice side benefit is that you don't have to remember to upgrade the app since pipx run will automatically run a recent version for you. Okay, let's see what this looks like in practice! pipx run APP [ARGS...] This will install the package in an isolated, temporary directory and invoke the app. Give it a try: > pipx run pycowsay moo --- < moo > --- \\ ^__^ \\ (oo)\\_______ (__)\\ )\\/\\ ||----w | || || Notice that you don't need to execute any install commands to run the app . Any arguments after the application name will be passed directly to the application: > pipx run pycowsay these arguments are all passed to pycowsay! ------------------------------------------- < these arguments are all passed to pycowsay! > ------------------------------------------- \\ ^__^ \\ (oo)\\_______ (__)\\ )\\/\\ ||----w | || || Re-running the same app is quick because pipx caches Virtual Environments on a per-app basis. The caches only last a few days, and when they expire, pipx will again use the latest version of the package. This way you can be sure you're always running a new version of the package without having to manually upgrade. If the app name does not match that package name, you can use the --spec arguemnt: pipx run --spec $PACKAGE $APP You can also use the --spec argument to run a specific version, or use any other pip -specifier: pipx run --spec PACKAGE==1.0.0 $APP Running from Source Control You can also run from a git repository. Here, black is used as an example. pipx run --spec git+https://github.com/psf/black.git black pipx run --spec git+https://github.com/psf/black.git@branch black # branch of your choice pipx run --spec git+https://github.com/psf/black.git@ce14fa8b497bae2b50ec48b3bd7022573a59cdb1 black # git hash pipx run --spec https://github.com/psf/black/archive/18.9b0.zip black # install a release Running from URL You can run .py files directly, too. pipx run https://gist.githubusercontent.com/cs01/fa721a17a326e551ede048c5088f9e0f/raw/6bdfbb6e9c1132b1c38fdd2f195d4a24c540c324/pipx-demo.py pipx is working! Summary That's it! Those are the most important commands pipx offers. To see all of pipx's documentation, run pipx --help or see the docs . Testimonials \"Thanks for improving the workflow that pipsi has covered in the past. Nicely done!\" \u2014 Jannis Leidel , PSF fellow, former pip and Django core developer, and founder of the Python Packaging Authority (PyPA) \"My setup pieces together pyenv, poetry, and pipx. [...] For the things I need, it\u2019s perfect.\" \u2014 Jacob Kaplan-Moss , co-creator of Django in blog post My Python Development Environment, 2020 Edition \"I'm a big fan of pipx. I think pipx is super cool.\" \u2014 Michael Kennedy , co-host of PythonBytes podcast in episode 139 Credits pipx was inspired by pipsi and npx . It was created by Chad Smith and has had lots of help from contributors . The logo was created by @IrishMorales . pipx is maintained by a team of volunteers (in alphabetical order) Bern\u00e1t G\u00e1bor Chad Smith Diego Fernandez Matthew Clapp Shawn Hensley Contributing Issues and Pull Requests are definitely welcome! Check out Contributing to get started.","title":"Home"},{"location":"#pipx-install-and-run-python-applications-in-isolated-environments","text":"Documentation : https://pipxproject.github.io/pipx/ Source Code : https://github.com/pipxproject/pipx For comparison to other tools including pipsi, see Comparison to Other Tools .","title":"pipx \u2014 Install and Run Python Applications in Isolated Environments"},{"location":"#install-pipx","text":"On macOS: brew install pipx pipx ensurepath Upgrade pipx with brew update && brew upgrade pipx . Otherwise, install via pip: python3 -m pip install --user pipx python3 -m pipx ensurepath Upgrade pipx with python3 -m pip install --user -U pipx . Shell completions are available by following the instructions printed with this command: pipx completions For more details, see the installation instructions .","title":"Install pipx"},{"location":"#overview-what-is-pipx","text":"pipx is a tool to help you install and run end-user applications written in Python. It's roughly similar to macOS's brew , JavaScript's npx , and Linux's apt . It's closely related to pip. In fact, it uses pip, but is focused on installing and managing Python packages that can be run from the command line directly as applications.","title":"Overview: What is pipx?"},{"location":"#how-is-it-different-from-pip","text":"pip is a general-purpose package installer for both libraries and apps with no environment isolation. pipx is made specifically for application installation, as it adds isolation yet still makes the apps available in your shell: pipx creates an isolated environment for each application and its associated packages. pipx does not ship with pip, but installing it is often an important part of bootstrapping your system.","title":"How is it Different from pip?"},{"location":"#where-does-pipx-install-apps-from","text":"By default, pipx uses the same package index as pip, PyPI . pipx can also install from all other sources pip can, such as a local directory, wheel, git url, etc. Python and PyPI allow developers to distribute code with \"console script entry points\". These entry points let users call into Python code from the command line, effectively acting like standalone applications. pipx is a tool to install and run any of these thousands of application-containing packages in a safe, convenient, and reliable way. In a way, it turns Python Package Index (PyPI) into a big app store for Python applications. Not all Python packages have entry points, but many do. If you would like to make your package compatible with pipx, all you need to do is add a console scripts entry point. If you're a poetry user, use these instructions .","title":"Where Does pipx Install Apps From?"},{"location":"#features","text":"pipx enables you to Expose CLI entrypoints of packages (\"apps\") installed to isolated environments with the install command. This guarantees no dependency conflicts and clean uninstalls! Easily list, upgrade, and uninstall packages that were installed with pipx Run the latest version of a Python application in a temporary environment with the run command Best of all, pipx runs with regular user permissions, never calling sudo pip install (you aren't doing that, are you? \ud83d\ude04).","title":"Features"},{"location":"#walkthrough-installing-a-package-and-its-applications-with-pipx","text":"You can globally install an application by running pipx install PACKAGE This automatically creates a virtual environment, installs the package, and adds the package's associated applications (entry points) to a location on your PATH . For example, pipx install pycowsay makes the pycowsay command available globally, but sandboxes the pycowsay package in its own virtual environment. pipx never needs to run as sudo to do this. Example: >> pipx install pycowsay installed package pycowsay 2.0.3, Python 3.7.3 These apps are now globally available - pycowsay done! \u2728 \ud83c\udf1f \u2728 >> pipx list venvs are in /home/user/.local/pipx/venvs apps are exposed on your $PATH at /home/user/.local/bin package pycowsay 2.0.3, Python 3.7.3 - pycowsay # Now you can run pycowsay from anywhere >> pycowsay mooo ____ < mooo > ==== \\ \\ ^__^ (oo)\\_______ (__)\\ )\\/\\ ||----w | || ||","title":"Walkthrough: Installing a Package and its Applications With pipx"},{"location":"#installing-from-source-control","text":"You can also install from a git repository. Here, black is used as an example. pipx install git+https://github.com/psf/black.git pipx install git+https://github.com/psf/black.git@branch # branch of your choice pipx install git+https://github.com/psf/black.git@ce14fa8b497bae2b50ec48b3bd7022573a59cdb1 # git hash pipx install https://github.com/psf/black/archive/18.9b0.zip # install a release","title":"Installing from Source Control"},{"location":"#walkthrough-running-an-application-in-a-temporary-sandboxed-environment","text":"This is an alternative to pipx install . pipx run downloads and runs the above mentioned Python \"apps\" in a one-time, temporary environment, leaving your system untouched afterwards. This can be handy when you need to run the latest version of an app, but don't necessarily want it installed on your computer. You may want to do this when you are initializing a new project and want to set up the right directory structure, when you want to view the help text of an application, or if you simply want to run an app in a one-off case and leave your system untouched afterwards. For example, the blog post How to set up a perfect Python project uses pipx run to kickstart a new project with cookiecutter , a tool that creates projects from project templates. A nice side benefit is that you don't have to remember to upgrade the app since pipx run will automatically run a recent version for you. Okay, let's see what this looks like in practice! pipx run APP [ARGS...] This will install the package in an isolated, temporary directory and invoke the app. Give it a try: > pipx run pycowsay moo --- < moo > --- \\ ^__^ \\ (oo)\\_______ (__)\\ )\\/\\ ||----w | || || Notice that you don't need to execute any install commands to run the app . Any arguments after the application name will be passed directly to the application: > pipx run pycowsay these arguments are all passed to pycowsay! ------------------------------------------- < these arguments are all passed to pycowsay! > ------------------------------------------- \\ ^__^ \\ (oo)\\_______ (__)\\ )\\/\\ ||----w | || || Re-running the same app is quick because pipx caches Virtual Environments on a per-app basis. The caches only last a few days, and when they expire, pipx will again use the latest version of the package. This way you can be sure you're always running a new version of the package without having to manually upgrade. If the app name does not match that package name, you can use the --spec arguemnt: pipx run --spec $PACKAGE $APP You can also use the --spec argument to run a specific version, or use any other pip -specifier: pipx run --spec PACKAGE==1.0.0 $APP","title":"Walkthrough: Running an Application in a Temporary, Sandboxed Environment"},{"location":"#running-from-source-control","text":"You can also run from a git repository. Here, black is used as an example. pipx run --spec git+https://github.com/psf/black.git black pipx run --spec git+https://github.com/psf/black.git@branch black # branch of your choice pipx run --spec git+https://github.com/psf/black.git@ce14fa8b497bae2b50ec48b3bd7022573a59cdb1 black # git hash pipx run --spec https://github.com/psf/black/archive/18.9b0.zip black # install a release","title":"Running from Source Control"},{"location":"#running-from-url","text":"You can run .py files directly, too. pipx run https://gist.githubusercontent.com/cs01/fa721a17a326e551ede048c5088f9e0f/raw/6bdfbb6e9c1132b1c38fdd2f195d4a24c540c324/pipx-demo.py pipx is working!","title":"Running from URL"},{"location":"#summary","text":"That's it! Those are the most important commands pipx offers. To see all of pipx's documentation, run pipx --help or see the docs .","title":"Summary"},{"location":"#testimonials","text":"\"Thanks for improving the workflow that pipsi has covered in the past. Nicely done!\" \u2014 Jannis Leidel , PSF fellow, former pip and Django core developer, and founder of the Python Packaging Authority (PyPA) \"My setup pieces together pyenv, poetry, and pipx. [...] For the things I need, it\u2019s perfect.\" \u2014 Jacob Kaplan-Moss , co-creator of Django in blog post My Python Development Environment, 2020 Edition \"I'm a big fan of pipx. I think pipx is super cool.\" \u2014 Michael Kennedy , co-host of PythonBytes podcast in episode 139","title":"Testimonials"},{"location":"#credits","text":"pipx was inspired by pipsi and npx . It was created by Chad Smith and has had lots of help from contributors . The logo was created by @IrishMorales . pipx is maintained by a team of volunteers (in alphabetical order) Bern\u00e1t G\u00e1bor Chad Smith Diego Fernandez Matthew Clapp Shawn Hensley","title":"Credits"},{"location":"#contributing","text":"Issues and Pull Requests are definitely welcome! Check out Contributing to get started.","title":"Contributing"},{"location":"changelog/","text":"0.15.1.4 - [bugfix] Replaced implicit dependency on setuptools with an explicit dependency on packaging (#339). 0.15.1.3 [bugfix] On Windows, pipx now lists correct Windows apps (#217) [bugfix] Fixed a pipx install bug causing incorrect python binary to be used when using the optional --python argument in certain situations, such as running pipx from a Framework python on macOS and specifying a non-Framework python. 0.15.1.2 [bugfix] Fix recursive search of dependencies' apps so no apps are missed. upgrade-all now skips editable packages, because pip disallows upgrading editable packages. 0.15.1.1 [bugfix] fix regression that caused installing with --editable flag to fail package name determination. 0.15.1.0 Add Python 3.8 to PyPI classifier and travis test matrix [feature] auto-upgrade shared libraries, including pip, if older than one month. Hide all pip warnings that a new version is available. (#264) [bugfix] pass pip arguments to pip when determining package name (#320) 0.15.0.0 Upgrade instructions: When upgrading to 0.15.0.0 or above from a pre-0.15.0.0 version, you must re-install all packages to take advantage of the new persistent pipx metadata files introduced in this release. These metadata files store pip specification values, injected packages, any custom pip arguments, and more in each main package's venv. You can do this by running pipx reinstall-all or pipx uninstall-all , then reinstalling manually. install now has no --spec option. You may specify any valid pip specification for install 's main argument. inject will now accept pip specifications for dependency arguments Metadata is now stored for each application installed, including install options like --spec , and injected packages. This information allows upgrade, upgrade-all and reinstall-all to work properly even with non-pypi installed packages. (#222) upgrade options --spec and --include-deps were removed. Pipx now uses the original options used to install each application instead. (#222) upgrade-all options --include-deps , --system-site-packages , --index-url , --editable , and --pip-args were removed. Pipx now uses the original options used to install each application instead. (#222) reinstall-all options --include-deps , --system-site-packages , --index-url , --editable , and --pip-args were removed. Pipx now uses the original options used to install each application instead. (#222) Handle missing interpreters more gracefully (#146) Change reinstall-all to use system python by default for apps. Now use --python option to specify a different python version. Remove the PYTHONPATH environment variable when executing any command to prevent conflicts between pipx dependencies and package dependencies when pipx is installed via homebrew. Homebrew can use pythonpath manipulation instead of virtual environments. (#233) Add printed summary after successful call to pipx inject Support associating apps with Python 3.5 Improvements to animation status text Make --python argument in reinstall-all command optional Use threads on OS's without support for semaphores Stricter parsing when passing -- argument as delimeter 0.14.0.0 Speed up operations by using shared venv for pip , setuptools , and wheel . You can see more detail in the 'how pipx works' section of the documentation. (#164, @pfmoore) Breaking change: for the inject command, change --include-binaries to --include-apps Change all terminology from binary to app or application Improve argument parsing for pipx run and pipx runpip If --force is passed, remove existing files in PIPX_BIN_DIR Move animation to start of line, hide cursor when animating 0.13.2.3 Fix regression when installing a package that doesn't have any entry points 0.13.2.2 Remove unneccesary and sometimes incorrect check after pipx inject (#195) Make status text/animation reliably disappear before continuing Update animation symbols 0.13.2.1 Remove virtual environment if installation did not complete. For example, if it was interrupted by ctrl+c or if an exception occurred for any reason. (#193) 0.13.2.0 Add shell autocompletions. Also add pipx completions command to print instructions on how to add pipx completions to your shell. Un-deprecate ensurepath . Use userpath internally instead of instructing users to run the userpath cli command. Improve detection of PIPX_BIN_DIR not being on PATH Improve error message when an existing symlink exists in PIPX_BIN_DIR and points to the wrong location Improve handling of unexpected files in PIPX_HOME (@uranusjr) swap out of order logic in order to correctly recommend --include-deps (@joshuarli) [dev] Migrate from tox to nox 0.13.1.1 Do not raise bare exception if no binaries found (#150) Update pipsi migration script 0.13.1.0 Deprecate ensurepath command. Use userpath append ~/.local/bin Support redirects and proxies when downloading python files (i.e. pipx run http://url/file.py ) Use tox for document generation and CI testing (CI tests are now functional rather than static tests on style and formatting!) Use mkdocs for documentation Change default cache duration for pipx run from 2 to 14 days 0.13.0.1 Fix upgrade-all and reinstall-all regression 0.13.0.0 Add runpip command to run arbitrary pip commands in pipx-managed virtual environments Do not raise error when running pipx install PACKAGE and the package has already been installed by pipx (#125). This is the cause of the major version change from 0.12 to 0.13. Add --skip argument to upgrade-all and reinstall-all commands, to let the user skip particular packages 0.12.3.3 Update logic in determining a package's binaries during installation. This removes spurious binaries from the installation. (#104) Improve compatibility with Debian distributions by using shutil.which instead of distutils.spawn.find_executable (#102) 0.12.3.2 Fix infinite recursion error when installing package such as cloudtoken==0.1.84 (#103) Fix windows type errors (#96, #98) 0.12.3.1 Fix \"WindowsPath is not iterable\" bug 0.12.3.0 Add --include-deps argument to include binaries of dependent packages when installing with pipx. This improves compatibility with packages that depend on other installed packages, such as jupyter . Speed up pipx list output (by running multiple processes in parallel) and by collecting all metadata in a single subprocess call More aggressive cache directory removal when --no-cache is passed to pipx run [dev] Move inline text passed to subprocess calls to their own files to enable autoformating, linting, unit testing 0.12.2.0 Add support for PEP 582's __pypackages__ (experimental). pipx run BINARY will first search in __pypackages__ for binary, then fallback to installing from PyPI. pipx run --pypackages BINARY will raise an error if the binary is not found in __pypackages__ . Fix regression when installing with --editable flag (#93) [dev] improve unit tests 0.12.1.0 Cache and reuse temporary Virtual Environments created with pipx run (#61) Update binary discovery logic to find \"scripts\" like awscli (#91) Forward --pip-args to the pip upgrade command (previously the args were forwarded to install/upgrade commands for packages) (#77) When using environment variable PIPX_HOME, Virtual Environments will now be created at $PIPX_HOME/venvs rather than at $PIPX_HOME . [dev] refactor into multiple files, add more unit tests 0.12.0.4 Fix parsing bug in pipx run 0.12.0.3 list python2 as supported language so that pip installs with python2 will no longer install the pipx on PyPI from the original pipx owner. Running pipx with python2 will fail, but at least it will not be as confusing as running the pipx package from the original owner. 0.12.0.2 forward arguments to run command correctly #90 0.12.0.1 stop using unverified context #89 0.12.0.0 Change installation instructions to use pipx PyPI name Add ensurepath command 0.11.0.2 add version argument parsing back in (fixes regression) 0.11.0.1 add version check, command check, fix printed version update installation instructions 0.11.0.0 Replace pipx BINARY with pipx run BINARY to run a binary in an ephemeral environment. This is a breaking API change so the major version has been incremented. (Issue #69) upgrade pip when upgrading packages (Issue #72) support --system-site-packages flag (Issue #64) 0.10.4.1 Fix version printed when pipx --version is run 0.10.4.0 Add --index-url, --editable, and --pip-args flags Updated README with pipsi migration instructions 0.10.3.0 Display python version in list Do not reinstall package if already installed (added --force flag to override) When upgrading all packages, print message only when package is updated Avoid accidental execution of pipx. main","title":"Changelog"},{"location":"comparisons/","text":"pipx vs pip pip is a general Python package installer. It can be used to install libraries or cli applications with entrypoints. pipx is a specialized package installer. It can only be used to install packages with cli entrypoints. pipx and pip both install packages from PyPI (or locally) pipx relies on pip (and venv) pipx replaces a subset of pip's functionality; it lets you install cli applications but NOT libraries that you import in your code. you can install pipx with pip Example interaction: Install pipx with pip: pip install --user pipx pipx vs poetry and pipenv pipx is used solely for application consumption: you install cli apps with it pipenv and poetry are cli apps used to develop applications and libraries all three tools wrap pip and virtual envrionments for more convenient workflows Example interaction: Install pipenv and poetry with pipx: pipx install poetry Run pipenv or poetry with pipx: pipx run poetry --help pipx vs venv venv is part of Python's standard library in Python 3.2 and above venv creates \"virtual environments\" which are sandboxed python installations pipx heavily relies on the venv package Example interaction: pipx installs packages to environments created with venv. pipx install black --verbose pipx vs pyenv pyenv manages python versions on your system. It helps you install versions like Python 3.6, 3.7, etc. pipx installs packages in virtual environments and exposes their entrypoints on your PATH Example interaction: Install a Python interpreter with pyenv, then install a package using pipx and that new interpreter: pipx install black --python3.7 where python3.7 was installed on the system with pyenv pipx vs pipsi pipx and pipsi both install packages in a similar way pipx is under active development. pipsi is no longer maintained. pipx always makes sure you're using the latest version of pip pipx has the ability to run a app in one line, leaving your system unchanged after it finishes ( pipx run APP ) where pipsi does not pipx has the ability to recursively install binaries from dependent packages pipx adds more useful information to its output pipx has more CLI options such as upgrade-all, reinstall-all, uninstall-all pipx is more modern. It uses Python 3.6+, and the venv package in the Python3 standard library instead of the python 2 package virtualenv . pipx works with Python homebrew installations while pipsi does not (at least on my machine) pipx defaults to less verbose output pipx allows you to see each command it runs by passing the --verbose flag pipx prints emojies \ud83d\ude00 Example interaction: None. Either one or the other should be used. These tools compete for a similar workflow. Migrating to pipx from pipsi After you have installed pipx, run migrate_pipsi_to_pipx.py . Why not do this with your new pipx installation? pipx run https://raw.githubusercontent.com/pipxproject/pipx/master/scripts/migrate_pipsi_to_pipx.py pipx vs brew Both brew and pipx install cli tools They install them from different sources. brew uses a curated repository specifically for brew, and pipx generally uses PyPI. Example interaction: brew can be used to install pipx, but they generally don't interact much. pipx vs npx Both can run cli tools (npx will search for them in node_modules, and if not found run in a temporary environment. pipx run wil search in __pypackages__ and if not found run in a temporary environment) npx works with JavaScript and pipx works with Python Both tools attempt to make runnning executables written in a dynamic language (JS/Python) as easy as possible pipx can also install tools globally; npx cannot Example interaction: None. These tools work for different languages. pipx vs pip-run pip-run is focused on running arbitrary Python code in ephemeral environments while pipx is focused on running Python binaries in ephemeral and non-ephemeral environments . For example these two commands both install poetry to an ephemeral environment and invoke poetry with --help . pipx run poetry --help pip-run poetry -- -m poetry --help Example interaction: None.","title":"Comparison to Other Tools"},{"location":"comparisons/#pipx-vs-pip","text":"pip is a general Python package installer. It can be used to install libraries or cli applications with entrypoints. pipx is a specialized package installer. It can only be used to install packages with cli entrypoints. pipx and pip both install packages from PyPI (or locally) pipx relies on pip (and venv) pipx replaces a subset of pip's functionality; it lets you install cli applications but NOT libraries that you import in your code. you can install pipx with pip Example interaction: Install pipx with pip: pip install --user pipx","title":"pipx vs pip"},{"location":"comparisons/#pipx-vs-poetry-and-pipenv","text":"pipx is used solely for application consumption: you install cli apps with it pipenv and poetry are cli apps used to develop applications and libraries all three tools wrap pip and virtual envrionments for more convenient workflows Example interaction: Install pipenv and poetry with pipx: pipx install poetry Run pipenv or poetry with pipx: pipx run poetry --help","title":"pipx vs poetry and pipenv"},{"location":"comparisons/#pipx-vs-venv","text":"venv is part of Python's standard library in Python 3.2 and above venv creates \"virtual environments\" which are sandboxed python installations pipx heavily relies on the venv package Example interaction: pipx installs packages to environments created with venv. pipx install black --verbose","title":"pipx vs venv"},{"location":"comparisons/#pipx-vs-pyenv","text":"pyenv manages python versions on your system. It helps you install versions like Python 3.6, 3.7, etc. pipx installs packages in virtual environments and exposes their entrypoints on your PATH Example interaction: Install a Python interpreter with pyenv, then install a package using pipx and that new interpreter: pipx install black --python3.7 where python3.7 was installed on the system with pyenv","title":"pipx vs pyenv"},{"location":"comparisons/#pipx-vs-pipsi","text":"pipx and pipsi both install packages in a similar way pipx is under active development. pipsi is no longer maintained. pipx always makes sure you're using the latest version of pip pipx has the ability to run a app in one line, leaving your system unchanged after it finishes ( pipx run APP ) where pipsi does not pipx has the ability to recursively install binaries from dependent packages pipx adds more useful information to its output pipx has more CLI options such as upgrade-all, reinstall-all, uninstall-all pipx is more modern. It uses Python 3.6+, and the venv package in the Python3 standard library instead of the python 2 package virtualenv . pipx works with Python homebrew installations while pipsi does not (at least on my machine) pipx defaults to less verbose output pipx allows you to see each command it runs by passing the --verbose flag pipx prints emojies \ud83d\ude00 Example interaction: None. Either one or the other should be used. These tools compete for a similar workflow.","title":"pipx vs pipsi"},{"location":"comparisons/#migrating-to-pipx-from-pipsi","text":"After you have installed pipx, run migrate_pipsi_to_pipx.py . Why not do this with your new pipx installation? pipx run https://raw.githubusercontent.com/pipxproject/pipx/master/scripts/migrate_pipsi_to_pipx.py","title":"Migrating to pipx from pipsi"},{"location":"comparisons/#pipx-vs-brew","text":"Both brew and pipx install cli tools They install them from different sources. brew uses a curated repository specifically for brew, and pipx generally uses PyPI. Example interaction: brew can be used to install pipx, but they generally don't interact much.","title":"pipx vs brew"},{"location":"comparisons/#pipx-vs-npx","text":"Both can run cli tools (npx will search for them in node_modules, and if not found run in a temporary environment. pipx run wil search in __pypackages__ and if not found run in a temporary environment) npx works with JavaScript and pipx works with Python Both tools attempt to make runnning executables written in a dynamic language (JS/Python) as easy as possible pipx can also install tools globally; npx cannot Example interaction: None. These tools work for different languages.","title":"pipx vs npx"},{"location":"comparisons/#pipx-vs-pip-run","text":"pip-run is focused on running arbitrary Python code in ephemeral environments while pipx is focused on running Python binaries in ephemeral and non-ephemeral environments . For example these two commands both install poetry to an ephemeral environment and invoke poetry with --help . pipx run poetry --help pip-run poetry -- -m poetry --help Example interaction: None.","title":"pipx vs pip-run"},{"location":"contributing/","text":"Thanks for your interest in contributing to pipx! Running pipx From Source Tree To run the pipx executable from your source tree during development, run pipx from the src directory: python src/pipx --version Running Tests Setup pipx uses an automation tool called nox for development, continuous integration testing, and various tasks. nox defines tasks or \"sessions\" in noxfile.py which can be run with nox -s SESSION_NAME . Session names can be listed with nox -l . Install nox for pipx development: python -m pip install --user git+https://github.com/cs01/nox.git@5ea70723e9e6 nox Note A specific version of nox must be used for pipx development until nox issue 233 is resolved. Tests are defined as nox sessions. You can see all nox sessions with nox -l At the time of this writing, the output looks like this >> nox -l Sessions defined in /home/csmith/git/pipx/noxfile.py: * tests-3.6 * tests-3.7 * tests-3.8 - cover -> Coverage analysis * lint * docs - develop-3.6 - develop-3.7 - develop-3.8 - build - publish - watch_docs - publish_docs Unit Tests To run unit tests in Python3.7, you can run nox -s tests-3.7 Tip You can running a specific unit test by passing arguments to pytest, the test runner pipx uses: nox -s tests-3.8 -- -k EXPRESSION Expression can be a test name, such as nox -s tests-3.8 -- -k test_uninstall Coverage errors can usually be ignored when only running a subset of tests. Lint Tests nox -s lint Testing pipx on Continuous Integration builds When you push a new git branch, tests will automatically be run against your code as defined in .travis . Building Documentation pipx autogenerates API documentation, and also uses templates. When updating pipx docs, make sure you are either modifying a file in the templates directory, or the docs directory. If in the docs directory, make sure the file was not autogenerated from the templates directory. Autogenerated files have a note at the top of the file. You can generate the documentation with nox -s docs This will capture CLI documentation for any pipx argument modifications, as well as generate templates to the docs directory. To preview changes, including live reloading, open another terminal and run nox -s watch_docs Publishing Doc Changes to GitHub pages nox -s publish_docs Releasing New pipx Versions To create a new release update pipx's version in main.py and regenerate documentation make sure the changelog is updated Finally, run nox -s publish nox -s publish_docs and create a new release in GitHub.","title":"Contributing"},{"location":"contributing/#running-pipx-from-source-tree","text":"To run the pipx executable from your source tree during development, run pipx from the src directory: python src/pipx --version","title":"Running pipx From Source Tree"},{"location":"contributing/#running-tests","text":"","title":"Running Tests"},{"location":"contributing/#setup","text":"pipx uses an automation tool called nox for development, continuous integration testing, and various tasks. nox defines tasks or \"sessions\" in noxfile.py which can be run with nox -s SESSION_NAME . Session names can be listed with nox -l . Install nox for pipx development: python -m pip install --user git+https://github.com/cs01/nox.git@5ea70723e9e6 nox Note A specific version of nox must be used for pipx development until nox issue 233 is resolved. Tests are defined as nox sessions. You can see all nox sessions with nox -l At the time of this writing, the output looks like this >> nox -l Sessions defined in /home/csmith/git/pipx/noxfile.py: * tests-3.6 * tests-3.7 * tests-3.8 - cover -> Coverage analysis * lint * docs - develop-3.6 - develop-3.7 - develop-3.8 - build - publish - watch_docs - publish_docs","title":"Setup"},{"location":"contributing/#unit-tests","text":"To run unit tests in Python3.7, you can run nox -s tests-3.7 Tip You can running a specific unit test by passing arguments to pytest, the test runner pipx uses: nox -s tests-3.8 -- -k EXPRESSION Expression can be a test name, such as nox -s tests-3.8 -- -k test_uninstall Coverage errors can usually be ignored when only running a subset of tests.","title":"Unit Tests"},{"location":"contributing/#lint-tests","text":"nox -s lint","title":"Lint Tests"},{"location":"contributing/#testing-pipx-on-continuous-integration-builds","text":"When you push a new git branch, tests will automatically be run against your code as defined in .travis .","title":"Testing pipx on Continuous Integration builds"},{"location":"contributing/#building-documentation","text":"pipx autogenerates API documentation, and also uses templates. When updating pipx docs, make sure you are either modifying a file in the templates directory, or the docs directory. If in the docs directory, make sure the file was not autogenerated from the templates directory. Autogenerated files have a note at the top of the file. You can generate the documentation with nox -s docs This will capture CLI documentation for any pipx argument modifications, as well as generate templates to the docs directory. To preview changes, including live reloading, open another terminal and run nox -s watch_docs","title":"Building Documentation"},{"location":"contributing/#publishing-doc-changes-to-github-pages","text":"nox -s publish_docs","title":"Publishing Doc Changes to GitHub pages"},{"location":"contributing/#releasing-new-pipx-versions","text":"To create a new release update pipx's version in main.py and regenerate documentation make sure the changelog is updated Finally, run nox -s publish nox -s publish_docs and create a new release in GitHub.","title":"Releasing New pipx Versions"},{"location":"docs/","text":"pipx --help usage: pipx [-h] [--version] {install,inject,upgrade,upgrade-all,uninstall,uninstall-all,reinstall-all,list,run,runpip,ensurepath,completions} ... Install and execute apps from Python packages. Binaries can either be installed globally into isolated Virtual Environments or run directly in an temporary Virtual Environment. Virtual Environment location is ~/.local/pipx/venvs. Symlinks to apps are placed in ~/.local/bin. These locations can be overridden with the environment variables PIPX_HOME and PIPX_BIN_DIR, respectively. (Virtual Environments will be installed to $PIPX_HOME/venvs) optional arguments: -h, --help show this help message and exit --version Print version and exit subcommands: Get help for commands with pipx COMMAND --help {install,inject,upgrade,upgrade-all,uninstall,uninstall-all,reinstall-all,list,run,runpip,ensurepath,completions} install Install a package inject Install packages into an existing Virtual Environment upgrade Upgrade a package upgrade-all Upgrade all packages. Runs `pip install -U <pkgname>` for each package. uninstall Uninstall a package uninstall-all Uninstall all packages reinstall-all Reinstall all packages list List installed packages run Download the latest version of a package to a temporary virtual environment, then run an app from it. Also compatible with local `__pypackages__` directory (experimental). runpip Run pip in an existing pipx-managed Virtual Environment ensurepath Ensure directory where pipx stores apps is on your PATH environment variable. Note that running this may modify your shell's configuration file(s) such as '~/.bashrc'. completions Print instructions on enabling shell completions for pipx pipx install pipx install --help usage: pipx install [-h] [--include-deps] [--verbose] [--force] [--python PYTHON] [--system-site-packages] [--index-url INDEX_URL] [--editable] [--pip-args PIP_ARGS] package_spec The install command is the preferred way to globally install apps from python packages on your system. It creates an isolated virtual environment for the package, then ensures the package's apps are accessible on your $PATH. The result: apps you can run from anywhere, located in packages you can cleanly upgrade or uninstall. Guaranteed to not have dependency version conflicts or interfere with your OS's python packages. 'sudo' is not required to do this. pipx install PACKAGE_NAME pipx install --python PYTHON PACKAGE_NAME pipx install VCS_URL pipx install ZIP_FILE pipx install TAR_GZ_FILE The PACKAGE_SPEC argument is passed directly to `pip install`. The default virtual environment location is ~/.local/pipx and can be overridden by setting the environment variable `PIPX_HOME` (Virtual Environments will be installed to `$PIPX_HOME/venvs`). The default app location is ~/.local/bin and can be overridden by setting the environment variable `PIPX_BIN_DIR`. positional arguments: package_spec package name or pip installation spec optional arguments: -h, --help show this help message and exit --include-deps Include apps of dependent packages --verbose --force, -f Modify existing virtual environment and files in PIPX_BIN_DIR --python PYTHON The Python executable used to create the Virtual Environment and run the associated app/apps. Must be v3.5+. --system-site-packages Give the virtual environment access to the system site-packages dir. --index-url INDEX_URL, -i INDEX_URL Base URL of Python Package Index --editable, -e Install a project in editable mode --pip-args PIP_ARGS Arbitrary pip arguments to pass directly to pip install/upgrade commands pipx run pipx run --help usage: pipx run [-h] [--no-cache] [--pypackages] [--spec SPEC] [--verbose] [--python PYTHON] [--system-site-packages] [--index-url INDEX_URL] [--editable] [--pip-args PIP_ARGS] app ... Download the latest version of a package to a temporary virtual environment, then run an app from it. The environment will be cached and re-used for up to 14 days. This means subsequent calls to 'run' for the same package will be faster since they can re-use the cached Virtual Environment. In support of PEP 582 'run' will use apps found in a local __pypackages__ directory, if present. Please note that this behavior is experimental, and is a acts as a companion tool to pythonloc. It may be modified or removed in the future. See https://github.com/cs01/pythonloc. positional arguments: app ... app/package name and any arguments to be passed to it optional arguments: -h, --help show this help message and exit --no-cache Do not re-use cached virtual environment if it exists --pypackages Require app to be run from local __pypackages__ directory --spec SPEC The package name or specific installation source passed to pip. Runs `pip install -U SPEC`. For example `--spec mypackage==2.0.0` or `--spec git+https://github.com/user/repo.git@branch` --verbose --python PYTHON The Python version to run package's CLI app with. Must be v3.5+. --system-site-packages Give the virtual environment access to the system site-packages dir. --index-url INDEX_URL, -i INDEX_URL Base URL of Python Package Index --editable, -e Install a project in editable mode --pip-args PIP_ARGS Arbitrary pip arguments to pass directly to pip install/upgrade commands pipx upgrade pipx upgrade --help usage: pipx upgrade [-h] [--force] [--system-site-packages] [--index-url INDEX_URL] [--editable] [--pip-args PIP_ARGS] [--verbose] package Upgrade a package in a pipx-managed Virtual Environment by running 'pip install --upgrade PACKAGE' positional arguments: package optional arguments: -h, --help show this help message and exit --force, -f Modify existing virtual environment and files in PIPX_BIN_DIR --system-site-packages Give the virtual environment access to the system site-packages dir. --index-url INDEX_URL, -i INDEX_URL Base URL of Python Package Index --editable, -e Install a project in editable mode --pip-args PIP_ARGS Arbitrary pip arguments to pass directly to pip install/upgrade commands --verbose pipx upgrade-all pipx upgrade-all --help usage: pipx upgrade-all [-h] [--skip SKIP [SKIP ...]] [--force] [--verbose] Upgrades all packages within their virtual environments by running 'pip install --upgrade PACKAGE' optional arguments: -h, --help show this help message and exit --skip SKIP [SKIP ...] skip these packages --force, -f Modify existing virtual environment and files in PIPX_BIN_DIR --verbose pipx inject pipx inject --help usage: pipx inject [-h] [--include-apps] [--include-deps] [--system-site-packages] [--index-url INDEX_URL] [--editable] [--pip-args PIP_ARGS] [--force] [--verbose] package dependencies [dependencies ...] Installs packages to an existing pipx-managed virtual environment. positional arguments: package Name of the existing pipx-managed Virtual Environment to inject into dependencies the packages to inject into the Virtual Environment-- either package name or pip package spec optional arguments: -h, --help show this help message and exit --include-apps Add apps from the injected packages onto your PATH --include-deps Include apps of dependent packages --system-site-packages Give the virtual environment access to the system site-packages dir. --index-url INDEX_URL, -i INDEX_URL Base URL of Python Package Index --editable, -e Install a project in editable mode --pip-args PIP_ARGS Arbitrary pip arguments to pass directly to pip install/upgrade commands --force, -f Modify existing virtual environment and files in PIPX_BIN_DIR --verbose pipx uninstall pipx uninstall --help usage: pipx uninstall [-h] [--verbose] package Uninstalls a pipx-managed Virtual Environment by deleting it and any files that point to its apps. positional arguments: package optional arguments: -h, --help show this help message and exit --verbose pipx uninstall-all pipx uninstall-all --help usage: pipx uninstall-all [-h] [--verbose] Uninstall all pipx-managed packages optional arguments: -h, --help show this help message and exit --verbose pipx reinstall-all pipx reinstall-all --help usage: pipx reinstall-all [-h] [--python PYTHON] [--skip SKIP [SKIP ...]] [--verbose] Reinstalls all packages. Packages are uninstalled, then installed with pipx install PACKAGE with the same options used in the original install of PACKAGE. This is useful if you upgraded to a new version of Python and want all your packages to use the latest as well. optional arguments: -h, --help show this help message and exit --python PYTHON The Python executable used to recreate the Virtual Environment and run the associated app/apps. Must be v3.5+. --skip SKIP [SKIP ...] skip these packages --verbose pipx list pipx list --help usage: pipx list [-h] [--verbose] List packages and apps installed with pipx optional arguments: -h, --help show this help message and exit --verbose pipx runpip pipx runpip --help usage: pipx runpip [-h] [--verbose] package ... Run pip in an existing pipx-managed Virtual Environment positional arguments: package Name of the existing pipx-managed Virtual Environment to run pip in pipargs Arguments to forward to pip command optional arguments: -h, --help show this help message and exit --verbose","title":"Docs"},{"location":"docs/#pipx-install","text":"pipx install --help usage: pipx install [-h] [--include-deps] [--verbose] [--force] [--python PYTHON] [--system-site-packages] [--index-url INDEX_URL] [--editable] [--pip-args PIP_ARGS] package_spec The install command is the preferred way to globally install apps from python packages on your system. It creates an isolated virtual environment for the package, then ensures the package's apps are accessible on your $PATH. The result: apps you can run from anywhere, located in packages you can cleanly upgrade or uninstall. Guaranteed to not have dependency version conflicts or interfere with your OS's python packages. 'sudo' is not required to do this. pipx install PACKAGE_NAME pipx install --python PYTHON PACKAGE_NAME pipx install VCS_URL pipx install ZIP_FILE pipx install TAR_GZ_FILE The PACKAGE_SPEC argument is passed directly to `pip install`. The default virtual environment location is ~/.local/pipx and can be overridden by setting the environment variable `PIPX_HOME` (Virtual Environments will be installed to `$PIPX_HOME/venvs`). The default app location is ~/.local/bin and can be overridden by setting the environment variable `PIPX_BIN_DIR`. positional arguments: package_spec package name or pip installation spec optional arguments: -h, --help show this help message and exit --include-deps Include apps of dependent packages --verbose --force, -f Modify existing virtual environment and files in PIPX_BIN_DIR --python PYTHON The Python executable used to create the Virtual Environment and run the associated app/apps. Must be v3.5+. --system-site-packages Give the virtual environment access to the system site-packages dir. --index-url INDEX_URL, -i INDEX_URL Base URL of Python Package Index --editable, -e Install a project in editable mode --pip-args PIP_ARGS Arbitrary pip arguments to pass directly to pip install/upgrade commands","title":"pipx install"},{"location":"docs/#pipx-run","text":"pipx run --help usage: pipx run [-h] [--no-cache] [--pypackages] [--spec SPEC] [--verbose] [--python PYTHON] [--system-site-packages] [--index-url INDEX_URL] [--editable] [--pip-args PIP_ARGS] app ... Download the latest version of a package to a temporary virtual environment, then run an app from it. The environment will be cached and re-used for up to 14 days. This means subsequent calls to 'run' for the same package will be faster since they can re-use the cached Virtual Environment. In support of PEP 582 'run' will use apps found in a local __pypackages__ directory, if present. Please note that this behavior is experimental, and is a acts as a companion tool to pythonloc. It may be modified or removed in the future. See https://github.com/cs01/pythonloc. positional arguments: app ... app/package name and any arguments to be passed to it optional arguments: -h, --help show this help message and exit --no-cache Do not re-use cached virtual environment if it exists --pypackages Require app to be run from local __pypackages__ directory --spec SPEC The package name or specific installation source passed to pip. Runs `pip install -U SPEC`. For example `--spec mypackage==2.0.0` or `--spec git+https://github.com/user/repo.git@branch` --verbose --python PYTHON The Python version to run package's CLI app with. Must be v3.5+. --system-site-packages Give the virtual environment access to the system site-packages dir. --index-url INDEX_URL, -i INDEX_URL Base URL of Python Package Index --editable, -e Install a project in editable mode --pip-args PIP_ARGS Arbitrary pip arguments to pass directly to pip install/upgrade commands","title":"pipx run"},{"location":"docs/#pipx-upgrade","text":"pipx upgrade --help usage: pipx upgrade [-h] [--force] [--system-site-packages] [--index-url INDEX_URL] [--editable] [--pip-args PIP_ARGS] [--verbose] package Upgrade a package in a pipx-managed Virtual Environment by running 'pip install --upgrade PACKAGE' positional arguments: package optional arguments: -h, --help show this help message and exit --force, -f Modify existing virtual environment and files in PIPX_BIN_DIR --system-site-packages Give the virtual environment access to the system site-packages dir. --index-url INDEX_URL, -i INDEX_URL Base URL of Python Package Index --editable, -e Install a project in editable mode --pip-args PIP_ARGS Arbitrary pip arguments to pass directly to pip install/upgrade commands --verbose","title":"pipx upgrade"},{"location":"docs/#pipx-upgrade-all","text":"pipx upgrade-all --help usage: pipx upgrade-all [-h] [--skip SKIP [SKIP ...]] [--force] [--verbose] Upgrades all packages within their virtual environments by running 'pip install --upgrade PACKAGE' optional arguments: -h, --help show this help message and exit --skip SKIP [SKIP ...] skip these packages --force, -f Modify existing virtual environment and files in PIPX_BIN_DIR --verbose","title":"pipx upgrade-all"},{"location":"docs/#pipx-inject","text":"pipx inject --help usage: pipx inject [-h] [--include-apps] [--include-deps] [--system-site-packages] [--index-url INDEX_URL] [--editable] [--pip-args PIP_ARGS] [--force] [--verbose] package dependencies [dependencies ...] Installs packages to an existing pipx-managed virtual environment. positional arguments: package Name of the existing pipx-managed Virtual Environment to inject into dependencies the packages to inject into the Virtual Environment-- either package name or pip package spec optional arguments: -h, --help show this help message and exit --include-apps Add apps from the injected packages onto your PATH --include-deps Include apps of dependent packages --system-site-packages Give the virtual environment access to the system site-packages dir. --index-url INDEX_URL, -i INDEX_URL Base URL of Python Package Index --editable, -e Install a project in editable mode --pip-args PIP_ARGS Arbitrary pip arguments to pass directly to pip install/upgrade commands --force, -f Modify existing virtual environment and files in PIPX_BIN_DIR --verbose","title":"pipx inject"},{"location":"docs/#pipx-uninstall","text":"pipx uninstall --help usage: pipx uninstall [-h] [--verbose] package Uninstalls a pipx-managed Virtual Environment by deleting it and any files that point to its apps. positional arguments: package optional arguments: -h, --help show this help message and exit --verbose","title":"pipx uninstall"},{"location":"docs/#pipx-uninstall-all","text":"pipx uninstall-all --help usage: pipx uninstall-all [-h] [--verbose] Uninstall all pipx-managed packages optional arguments: -h, --help show this help message and exit --verbose","title":"pipx uninstall-all"},{"location":"docs/#pipx-reinstall-all","text":"pipx reinstall-all --help usage: pipx reinstall-all [-h] [--python PYTHON] [--skip SKIP [SKIP ...]] [--verbose] Reinstalls all packages. Packages are uninstalled, then installed with pipx install PACKAGE with the same options used in the original install of PACKAGE. This is useful if you upgraded to a new version of Python and want all your packages to use the latest as well. optional arguments: -h, --help show this help message and exit --python PYTHON The Python executable used to recreate the Virtual Environment and run the associated app/apps. Must be v3.5+. --skip SKIP [SKIP ...] skip these packages --verbose","title":"pipx reinstall-all"},{"location":"docs/#pipx-list","text":"pipx list --help usage: pipx list [-h] [--verbose] List packages and apps installed with pipx optional arguments: -h, --help show this help message and exit --verbose","title":"pipx list"},{"location":"docs/#pipx-runpip","text":"pipx runpip --help usage: pipx runpip [-h] [--verbose] package ... Run pip in an existing pipx-managed Virtual Environment positional arguments: package Name of the existing pipx-managed Virtual Environment to run pip in pipargs Arguments to forward to pip command optional arguments: -h, --help show this help message and exit --verbose","title":"pipx runpip"},{"location":"examples/","text":"pipx install examples pipx install pycowsay pipx install --python python3.6 pycowsay pipx install --python python3.7 pycowsay pipx install git+https://github.com/psf/black pipx install git+https://github.com/psf/black.git@branch-name pipx install git+https://github.com/psf/black.git@git-hash pipx install https://github.com/psf/black/archive/18.9b0.zip pipx install black[d] pipx install --include-deps jupyter pipx run examples pipx enables you to test various combinations of Python versions and package versions in ephemeral environments: pipx run BINARY # latest version of binary is run with python3 pipx run --spec PACKAGE==2.0.0 BINARY # specific version of package is run pipx run --python 3.4 BINARY # Installed and invoked with specific Python version pipx run --python 3.7 --spec PACKAGE=1.7.3 BINARY pipx run --spec git+https://url.git BINARY # latest version on master is run pipx run --spec git+https://url.git@branch BINARY pipx run --spec git+https://url.git@hash BINARY pipx run pycowsay moo pipx --version # prints pipx version pipx run pycowsay --version # prints pycowsay version pipx run --python pythonX pycowsay pipx run --spec pycowsay==2.0 pycowsay --version pipx run --spec git+https://github.com/psf/black.git black pipx run --spec git+https://github.com/psf/black.git@branch-name black pipx run --spec git+https://github.com/psf/black.git@git-hash black pipx run --spec https://github.com/psf/black/archive/18.9b0.zip black --help pipx run https://gist.githubusercontent.com/cs01/fa721a17a326e551ede048c5088f9e0f/raw/6bdfbb6e9c1132b1c38fdd2f195d4a24c540c324/pipx-demo.py pipx inject example One use of the inject command is setting up a REPL with some useful extra packages. pipx install ptpython pipx inject ptpython requests pendulum After running the above commands, you will be able to import and use the requests and pendulum packages inside a ptpython repl. pipx list example > pipx list venvs are in /Users/user/.local/pipx/venvs binaries are exposed on your $PATH at /Users/user/.local/bin package black 18.9b0, Python 3.7.0 - black - blackd package pipx 0.10.0, Python 3.7.0 - pipx","title":"Examples"},{"location":"examples/#pipx-install-examples","text":"pipx install pycowsay pipx install --python python3.6 pycowsay pipx install --python python3.7 pycowsay pipx install git+https://github.com/psf/black pipx install git+https://github.com/psf/black.git@branch-name pipx install git+https://github.com/psf/black.git@git-hash pipx install https://github.com/psf/black/archive/18.9b0.zip pipx install black[d] pipx install --include-deps jupyter","title":"pipx install examples"},{"location":"examples/#pipx-run-examples","text":"pipx enables you to test various combinations of Python versions and package versions in ephemeral environments: pipx run BINARY # latest version of binary is run with python3 pipx run --spec PACKAGE==2.0.0 BINARY # specific version of package is run pipx run --python 3.4 BINARY # Installed and invoked with specific Python version pipx run --python 3.7 --spec PACKAGE=1.7.3 BINARY pipx run --spec git+https://url.git BINARY # latest version on master is run pipx run --spec git+https://url.git@branch BINARY pipx run --spec git+https://url.git@hash BINARY pipx run pycowsay moo pipx --version # prints pipx version pipx run pycowsay --version # prints pycowsay version pipx run --python pythonX pycowsay pipx run --spec pycowsay==2.0 pycowsay --version pipx run --spec git+https://github.com/psf/black.git black pipx run --spec git+https://github.com/psf/black.git@branch-name black pipx run --spec git+https://github.com/psf/black.git@git-hash black pipx run --spec https://github.com/psf/black/archive/18.9b0.zip black --help pipx run https://gist.githubusercontent.com/cs01/fa721a17a326e551ede048c5088f9e0f/raw/6bdfbb6e9c1132b1c38fdd2f195d4a24c540c324/pipx-demo.py","title":"pipx run examples"},{"location":"examples/#pipx-inject-example","text":"One use of the inject command is setting up a REPL with some useful extra packages. pipx install ptpython pipx inject ptpython requests pendulum After running the above commands, you will be able to import and use the requests and pendulum packages inside a ptpython repl.","title":"pipx inject example"},{"location":"examples/#pipx-list-example","text":"> pipx list venvs are in /Users/user/.local/pipx/venvs binaries are exposed on your $PATH at /Users/user/.local/bin package black 18.9b0, Python 3.7.0 - black - blackd package pipx 0.10.0, Python 3.7.0 - pipx","title":"pipx list example"},{"location":"getting-started/","text":"Now that you have pipx installed, you can install a program: pipx install PACKAGE for example pipx install pycowsay You can list programs installed: pipx list Or you can run a program without installing it: pipx run pycowsay moooo! You can view documentation for all commands by running pipx --help .","title":"Getting Started"},{"location":"how-pipx-works/","text":"How it Works When installing a package and its binaries ( pipx install package ) pipx will create directory ~/.local/pipx/venvs/PACKAGE create or re-use a shared virtual environment that contains shared packaging libraries pip , setuptools and wheel in ~/.local/pipx/shared/ ensure all packaging libraries are updated to their latest versions create a Virtual Environment in ~/.local/pipx/venvs/PACKAGE that uses the shared pip mentioned above but otherwise is isolated (pipx uses a .pth file to do this) install the desired package in the Virtual Environment expose binaries at ~/.local/bin that point to new binaries in ~/.local/pipx/venvs/PACKAGE/bin (such as ~/.local/bin/black -> ~/.local/pipx/venvs/black/bin/black ) As long as ~/.local/bin/ is on your PATH, you can now invoke the new binaries globally When running a binary ( pipx run BINARY ), pipx will create or re-use a shared virtual environment that contains shared packaging libraries pip , setuptools and wheel in ~/.local/pipx/shared/ ensure all packaging libraries are updated to their latest versions create a temporary directory (or reuse a cached virtual environment for this package) with a name based on a hash of the attributes that make the run reproducible. This includes things like the package name, spec, python version, and pip arguments. create a Virtual Environment inside it with python -m venv install the desired package in the Virtual Environment invoke the binary These are all things you can do yourself, but pipx automates them for you. If you are curious as to what pipx is doing behind the scenes, you can always pass the --verbose flag to see every single command and argument being run. Developing for pipx If you are a developer and want to be able to run pipx install MY_PACKAGE make sure you include an entry_points section in your setup.py file. setup( # other arguments here... entry_points={ 'console_scripts': [ 'foo = my_package.some_module:main_func', 'bar = other_module:some_func', ], 'gui_scripts': [ 'baz = my_package_gui:start_func', ] } ) In this case main_func and some_func would be available to pipx after installing the above example package. For a real-world example, see pycowsay 's setup.py source code. You can read more about entry points here .","title":"How pipx works"},{"location":"how-pipx-works/#how-it-works","text":"When installing a package and its binaries ( pipx install package ) pipx will create directory ~/.local/pipx/venvs/PACKAGE create or re-use a shared virtual environment that contains shared packaging libraries pip , setuptools and wheel in ~/.local/pipx/shared/ ensure all packaging libraries are updated to their latest versions create a Virtual Environment in ~/.local/pipx/venvs/PACKAGE that uses the shared pip mentioned above but otherwise is isolated (pipx uses a .pth file to do this) install the desired package in the Virtual Environment expose binaries at ~/.local/bin that point to new binaries in ~/.local/pipx/venvs/PACKAGE/bin (such as ~/.local/bin/black -> ~/.local/pipx/venvs/black/bin/black ) As long as ~/.local/bin/ is on your PATH, you can now invoke the new binaries globally When running a binary ( pipx run BINARY ), pipx will create or re-use a shared virtual environment that contains shared packaging libraries pip , setuptools and wheel in ~/.local/pipx/shared/ ensure all packaging libraries are updated to their latest versions create a temporary directory (or reuse a cached virtual environment for this package) with a name based on a hash of the attributes that make the run reproducible. This includes things like the package name, spec, python version, and pip arguments. create a Virtual Environment inside it with python -m venv install the desired package in the Virtual Environment invoke the binary These are all things you can do yourself, but pipx automates them for you. If you are curious as to what pipx is doing behind the scenes, you can always pass the --verbose flag to see every single command and argument being run.","title":"How it Works"},{"location":"how-pipx-works/#developing-for-pipx","text":"If you are a developer and want to be able to run pipx install MY_PACKAGE make sure you include an entry_points section in your setup.py file. setup( # other arguments here... entry_points={ 'console_scripts': [ 'foo = my_package.some_module:main_func', 'bar = other_module:some_func', ], 'gui_scripts': [ 'baz = my_package_gui:start_func', ] } ) In this case main_func and some_func would be available to pipx after installing the above example package. For a real-world example, see pycowsay 's setup.py source code. You can read more about entry points here .","title":"Developing for pipx"},{"location":"installation/","text":"System Requirements python 3.6+ is required to install pipx. pipx can run binaries from packages with Python 3.3+. Don't have Python 3.6 or later? See Python 3 Installation & Setup Guide . You also need to have pip installed on your machine for python3 . Installing it varies from system to system. Consult pip's installation instructions . Installing on Linux works best with a Linux Package Manager . pipx works on macOS, linux, and Windows. Install pipx Assuming you have pip installed for python3, run: python3 -m pip install --user pipx python3 -m pipx ensurepath Installation Options pipx's default binary location is ~/.local/bin . This can be overriden with the environment variable PIPX_BIN_DIR . pipx's default virtual environment location is ~/.local/pipx . This can be overridden with the environment variable PIPX_HOME . Upgrade pipx python3 -m pip install --user -U pipx Note: Upgrading pipx from a pre-0.15.0.0 version to 0.15.0.0 or later After upgrading to pipx 0.15.0.0 or above from a pre-0.15.0.0 version, you must re-install all packages to take advantage of the new persistent pipx metadata files introduced in the 0.15.0.0 release. These metadata files store pip specification values, injected packages, any custom pip arguments, and more in each main package's venv. If you have no packages installed using the --spec option, and no venvs with injected packages, you can do this by running pipx reinstall-all . If you have any packages installed using the --spec option or venvs with injected packages, you should reinstall packages manually using pipx uninstall-all , followed by pipx install and possibly pipx inject . Shell Completion You can easily get your shell's tab completions working by following instructions printed with this command: pipx completions Install pipx Development Versions New versions of pipx are published as beta or release candidates. These versions look something like 0.13.0b1 , where b1 signifies the first beta release of version 0.13. These releases can be tested with pip install --user pipx --upgrade --dev","title":"Installation"},{"location":"installation/#system-requirements","text":"python 3.6+ is required to install pipx. pipx can run binaries from packages with Python 3.3+. Don't have Python 3.6 or later? See Python 3 Installation & Setup Guide . You also need to have pip installed on your machine for python3 . Installing it varies from system to system. Consult pip's installation instructions . Installing on Linux works best with a Linux Package Manager . pipx works on macOS, linux, and Windows.","title":"System Requirements"},{"location":"installation/#install-pipx","text":"Assuming you have pip installed for python3, run: python3 -m pip install --user pipx python3 -m pipx ensurepath","title":"Install pipx"},{"location":"installation/#installation-options","text":"pipx's default binary location is ~/.local/bin . This can be overriden with the environment variable PIPX_BIN_DIR . pipx's default virtual environment location is ~/.local/pipx . This can be overridden with the environment variable PIPX_HOME .","title":"Installation Options"},{"location":"installation/#upgrade-pipx","text":"python3 -m pip install --user -U pipx","title":"Upgrade pipx"},{"location":"installation/#note-upgrading-pipx-from-a-pre-01500-version-to-01500-or-later","text":"After upgrading to pipx 0.15.0.0 or above from a pre-0.15.0.0 version, you must re-install all packages to take advantage of the new persistent pipx metadata files introduced in the 0.15.0.0 release. These metadata files store pip specification values, injected packages, any custom pip arguments, and more in each main package's venv. If you have no packages installed using the --spec option, and no venvs with injected packages, you can do this by running pipx reinstall-all . If you have any packages installed using the --spec option or venvs with injected packages, you should reinstall packages manually using pipx uninstall-all , followed by pipx install and possibly pipx inject .","title":"Note: Upgrading pipx from a pre-0.15.0.0 version to 0.15.0.0 or later"},{"location":"installation/#shell-completion","text":"You can easily get your shell's tab completions working by following instructions printed with this command: pipx completions","title":"Shell Completion"},{"location":"installation/#install-pipx-development-versions","text":"New versions of pipx are published as beta or release candidates. These versions look something like 0.13.0b1 , where b1 signifies the first beta release of version 0.13. These releases can be tested with pip install --user pipx --upgrade --dev","title":"Install pipx Development Versions"},{"location":"programs-to-try/","text":"Here are some programs you can try out. If you've never used the program before, make sure you add the --help flag so it doesn't do something you don't expect. If you decide you want to install, you can run pipx install PACKAGE instead. pipx install ansible # IT automation pipx run asciinema # Record and share your terminal sessions, the right way. pipx run black # uncompromising Python code formatter pipx run --spec=babel pybabel --help # internationalizing and localizing Python applications pipx run --spec=chardet chardetect --help # detect file encoding pipx run cookiecutter # creates projects from project templates pipx run create-python-package # easily create and publish new Python packages pipx run flake8 # tool for style guide enforcement pipx run gdbgui # browser-based gdb debugger pipx run hexsticker # create hexagon stickers automatically pipx run ipython # powerful interactive Python shell pipx run jupyter # web-based notebook environment for interactive computing pipx run pipenv # python dependency/environment management pipx run poetry # python dependency/environment/packaging management pipx run pylint # source code analyzer pipx run pyinstaller # bundles a Python application and all its dependencies into a single package pipx run pyxtermjs # fully functional terminal in the browser pipx install shell-functools # Functional programming tools for the shell","title":"Programs to Try"}]}